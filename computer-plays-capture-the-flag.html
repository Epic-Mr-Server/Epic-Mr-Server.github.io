<!DOCTYPE html>
<html lang="en">
  <head>
    <title>
      Computer Plays Capture the Flag
    </title>
    <meta
      property="og:title"
      content="Creating-My-Face-With-Machine-Learning - Simplistic Limp Gerbil"
    />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta charset="utf-8" />
    <meta property="twitter:card" content="summary_large_image" />

    <style data-tag="reset-style-sheet">
      html {  line-height: 1.15;}body {  margin: 0;}* {  box-sizing: border-box;  border-width: 0;  border-style: solid;  -webkit-font-smoothing: antialiased;}p,li,ul,pre,div,h1,h2,h3,h4,h5,h6,figure,blockquote,figcaption {  margin: 0;  padding: 0;}button {  background-color: transparent;}button,input,optgroup,select,textarea {  font-family: inherit;  font-size: 100%;  line-height: 1.15;  margin: 0;}button,select {  text-transform: none;}button,[type="button"],[type="reset"],[type="submit"] {  -webkit-appearance: button;  color: inherit;}button::-moz-focus-inner,[type="button"]::-moz-focus-inner,[type="reset"]::-moz-focus-inner,[type="submit"]::-moz-focus-inner {  border-style: none;  padding: 0;}button:-moz-focus,[type="button"]:-moz-focus,[type="reset"]:-moz-focus,[type="submit"]:-moz-focus {  outline: 1px dotted ButtonText;}a {  color: inherit;  text-decoration: inherit;}input {  padding: 2px 4px;}img {  display: block;}details {  display: block;  margin: 0;  padding: 0;}summary::-webkit-details-marker {  display: none;}[data-thq="accordion"] [data-thq="accordion-content"] {  max-height: 0;  overflow: hidden;  transition: max-height 0.3s ease-in-out;  padding: 0;}[data-thq="accordion"] details[data-thq="accordion-trigger"][open] + [data-thq="accordion-content"] {  max-height: 1000vh;}details[data-thq="accordion-trigger"][open] summary [data-thq="accordion-icon"] {  transform: rotate(180deg);}html { scroll-behavior: smooth  }
    </style>

<script type="text/javascript">

	var CrewSetup = [29, 10, 10, 3];



var AgentsR1 = [];

var AgentsB1 = [];



var AgentsR2 = [];

var AgentsB2 = [];



var AgentsR3 = [];

var AgentsB3 = [];



var AgentsR4 = [];

var AgentsB4 = [];



var AgentsR5 = [];

var AgentsB5 = [];



var Objects = [];

var Wall = [];



var agentsCount = 100;



var Iterations = 100000;



var MutationChance = 0.01;



var MutationChange = .05;



var RandomVariationOnes = 2;



var KillDistance = .1;



var ChangesPerIteration = 1000;



var TeamMates = 5;



var distanceBetweenMembers = 10;



var NumberOthers = 10;



var canvas;



var canvas2;



var Shuffle = false;



var ctx;

var ctx2;



var PreviousValues = [0];

var started = true;
	
	var started2 = true;
	
function stop() {
	
	
	clearInterval(good);
	
	started = true;
	
	AgentsB1 = [];
	AgentsR1 = [];
	
	AgentsB2 = [];
	AgentsR2 = [];
	
	AgentsB3 = [];
	AgentsR3 = [];
	
	AgentsB4 = [];
	AgentsR4 = [];
	
	AgentsB5 = [];
	AgentsR5 = [];
	
	
}

function start() {

	

	canvas = document.getElementById("CoolKid");

	//canvas2 = document.getElementById("RadChart");



	ctx = canvas.getContext("2d");

	//ctx2 = canvas2.getContext("2d");

	if (started) {
		
		if (started2) {
			
			ctx.translate(250, 100);
			
		}
		started2 = false;
		
		
		
	
	started = false;

	





	

	

	var ke = -1;

	for (o = 0; o < agentsCount; o++) {



		

			ke++;



			agentFrameB.push(0);	

			agentFrameR.push(0);



			



		AgentsR1.push(new Agent(Weights(CrewSetup), Bias(CrewSetup), ke, -70, 3, 10, 10, 100, false, true, o, true, 1));

		AgentsB1.push(new Agent(Weights(CrewSetup), Bias(CrewSetup), ke, 70, 3, 10, 10, 100, false, true, o, false, 1));



	

		AgentsR2.push(new Agent(Weights(CrewSetup), Bias(CrewSetup), ke, -70, 3, 10, 10, 100, false, true, o, true, 2));

		AgentsB2.push(new Agent(Weights(CrewSetup), Bias(CrewSetup), ke, 70, 3, 10, 10, 100, false, true, o, false, 2));



		

		AgentsR3.push(new Agent(Weights(CrewSetup), Bias(CrewSetup), ke, -70, 3, 10, 10, 100, false, true, o, true, 3));

		AgentsB3.push(new Agent(Weights(CrewSetup), Bias(CrewSetup), ke, 70, 3, 10, 10, 100, false, true, o, false, 3));



		

		AgentsR4.push(new Agent(Weights(CrewSetup), Bias(CrewSetup), ke, -70, 3, 10, 10, 100, false, true, o, true, 4));

		AgentsB4.push(new Agent(Weights(CrewSetup), Bias(CrewSetup), ke, 70, 3, 10, 10, 100, false, true, o, false, 4));



		

		AgentsR5.push(new Agent(Weights(CrewSetup), Bias(CrewSetup), ke, -70, 3, 10, 10, 100, false, true, o, true, 5));

		AgentsB5.push(new Agent(Weights(CrewSetup), Bias(CrewSetup), ke, 70, 3, 10, 10, 100, false, true, o, false, 5));



		



		

		

	}

	

	

		

	Objects.push(new Object(1, 50, 0, 15, 15));

	Objects.push(new Object(2, -50, 0, 15, 15));

	 



	Wall.push(new Walls(-5, -50, 10, 110));

	Wall.push(new Walls(-100, -50, 200, 5));

	Wall.push(new Walls(-100, 55, 200, 5));

	

	

	

	

	good = setInterval(Test, 1);

	

	}

	

	

}



function Evolution(AgentsList) {



	var NextGeneration = []

	var Final = [];

	for (u67 = 0; u67 < AgentsList.length; u67++) {

		

		var gen = AgentsList[u67].AgentN;

		var Score = AgentsList[u67].score;

		

		

		Final.push({gen, Score});

		

	}

	

	var cool = []

	Final.sort(function (a, b) { return a.Score - b.Score;});

	

	

	for (n = 0; n < AgentsList.length; n++) {

		

		cool.push(AgentsList[n]);

		

	}

	



	

	var Surviving = [];

	for (n = RandomVariationOnes; n < Final.length; n++) {

		

		const Chance = n / (Final.length - 1);

		

		if (Chance >= (Math.random() * 1)) {

			

			

			Surviving.push(Final[n].gen);

			

		}

		

		

	}

	

	//Weights, Bias, AgentNum, x, Width, Height, Score



	var AgentKeepup = -1;

	

	for (n = 0; n < Surviving.length; n++) {

		 

		AgentKeepup++;

		var ActualAgent = cool[(Surviving[n])];



		var Greatest = n === Surviving.length - 1



		NextGeneration.push(new Agent(ActualAgent.W, ActualAgent.B, AgentsList[AgentKeepup].AgentN, AgentsList[AgentKeepup].StartX, AgentsList[AgentKeepup].StartY, AgentsList[AgentKeepup].Wi, AgentsList[AgentKeepup].He, 100, Greatest, true, AgentsList[AgentKeepup].Te, AgentsList[AgentKeepup].IsOnRed, AgentsList[AgentKeepup].ID));

		 

	}



	for (n = RandomVariationOnes; n < (cool.length - Surviving.length); n++) {

		 

		

		

		var Index1 = Math.floor(Math.random() * Surviving.length);

		var Index2 = Math.floor(Math.random() * Surviving.length);



		var Chance21 = (Index1 + 1) / Surviving.length;

		var Chance22 = (Index2 + 1) / Surviving.length;



		var Check1 = Math.random();

		var Check2 = Math.random();



		if (Check1 > Chance21 || Check2 > Chance22) {



			n -= 1;



			continue;



		}



		if (Index1 === Index2) {



			n -= 1;



			continue

		}



		AgentKeepup++;



		var Parent1 = cool[Surviving[Index1]];

		var Parent2 = cool[Surviving[Index2]];

		

		var NewWeights = [];

		var NewBias = [];

		

		for (o = 0; o < Parent1.W.length; o++) {

			

			var ToporBottom = Math.floor(Math.random() * 2);

			var Mutated = Math.random() < MutationChance;

			

			if (ToporBottom === 0) {

				

				var Lay = Parent1.W[o].Lay;

				var Va = Parent1.W[o].Va;

				

				if (Mutated) {

					

					Va += (Math.random() * (MutationChange * 2)) - MutationChange;

				

				}

				

				NewWeights.push({Lay, Va});

				

			} 

			if (ToporBottom === 1) {

				

				var Lay = Parent2.W[o].Lay;

				var Va = Parent2.W[o].Va;

				

				if (Mutated) {

					

					Va += (Math.random() * (MutationChange * 2)) - MutationChange;

					

				}

				

				NewWeights.push({Lay, Va});

				

			} 

			

			

			

		} 

		for (o = 0; o < Parent1.B.length; o++) {

			

			var ToporBottom = Math.floor(Math.random() * 2);

			var Mutated = Math.random() < MutationChance;

			

			if (ToporBottom === 0) {

				

				var Lay = Parent1.B[o].Lay;

				var Va = Parent1.B[o].Va;

				

				if (Mutated) {

					

					Va += (Math.random() * (MutationChange * 2)) - MutationChange;

					

				}

				

				NewBias.push({Lay, Va});

				

			} 

			if (ToporBottom === 1) {

				

				var Lay = Parent2.B[o].Lay;

				var Va = Parent2.B[o].Va;

				

				if (Mutated) {

					

					Va += (Math.random() * (MutationChange * 2)) - MutationChange;

					

				}

				

				NewBias.push({Lay, Va});

				

			} 

			

			

			

		} 

		

		



		NextGeneration.push(new Agent(NewWeights, NewBias, AgentsList[AgentKeepup].AgentN, AgentsList[AgentKeepup].StartX, AgentsList[AgentKeepup].StartY, AgentsList[AgentKeepup].Wi, AgentsList[AgentKeepup].He, 100, false, true, AgentsList[AgentKeepup].Te, AgentsList[AgentKeepup].IsOnRed, AgentsList[AgentKeepup].ID));

		

	}

	for (n = 0; n < RandomVariationOnes; n++) {



		AgentKeepup++;



		NextGeneration.push(new Agent(Weights(CrewSetup), Bias(CrewSetup), AgentsList[AgentKeepup].AgentN, AgentsList[AgentKeepup].StartX, AgentsList[AgentKeepup].StartY, AgentsList[AgentKeepup].Wi, AgentsList[AgentKeepup].He, 100, false, true, AgentsList[AgentKeepup].Te, AgentsList[AgentKeepup].IsOnRed, AgentsList[AgentKeepup].ID));



	}





	return NextGeneration;

	

	

}



var good;

var Sub = 0;

var IterationKeepup = -1;



var Dead = 0;

var RedWins = 0;



var agentFrameR = [];

var agentFrameB = [];



function TeamTest(Agents) {





	



	for (k = 0; k < Agents.length; k++) {



		var PlayerInPlay = Agents[k];

		//Get Inputs

		var ActualInputs = [];

		var Others = []



		if (PlayerInPlay.IsOnRed) {



			Others.push(AgentsB1[k]);

			Others.push(AgentsB2[k]);

			Others.push(AgentsB3[k]);

			Others.push(AgentsB4[k]);

			Others.push(AgentsB5[k]);



		}

		else {





			Others.push(AgentsR1[k]);

			Others.push(AgentsR2[k]);

			Others.push(AgentsR3[k]);

			Others.push(AgentsR4[k]);

			Others.push(AgentsR5[k]);

			



		}



		if (PlayerInPlay.alreadykilled.length > 0) {



			//Agents[k].score += .5;



		}

		/*

		var Completed = false;

		for (l = 0; l < Objects.length; l++) {



			if (PlayerInPlay.ObjectsCollected[l] === 0) {





				Completed = true;

			}



		}





		if (Completed && PlayerInPlay.IsOnRed) {



		



			Agents[k].score = Agents[k].score - 1;

			

			





		}

		*/

		



/*

		for (jh67 = 0; jh67 < NumberOthers; jh67++) {

			ActualInputs.push(0);

		}

		*/



		for (jh67 = 0; jh67 < Others.length; jh67++) {



			

			var ab = ((Others[jh67].X - PlayerInPlay.X));

			var bb = (Others[jh67].Y - PlayerInPlay.Y);



			if (ab < 0) {



				//ab = 110 - ab;



			}

			else {



				//ab = 110 - ab;

			}



			if (bb < 0) {



				//bb = 80 - bb;



			}

			else {



				//bb = 80 - bb;

			}





				ActualInputs.push(ab / 220);

				ActualInputs.push(bb / 160);

			

		}



		for (l45 = 0; l45 < Others.length; l45++) {



			if (l45 != k) {



				var Distance = Math.sqrt(Math.pow((Others[l45].X - PlayerInPlay.X), 2) + Math.pow((Others[l45].Y - PlayerInPlay.Y), 2));



				if (Distance < (KillDistance * 100) && Others[l45].Al) {





					ActualInputs.push(1);



				}

				else {



					ActualInputs.push(0);



				}

			}

		}

		//1 === Red 2 === Blue



		for (jh67 = 0; jh67 < Objects.length; jh67++) {



			if (PlayerInPlay.IsOnRed && Objects[jh67].ObjectN !== 1) {



				break;



			}

			else if (PlayerInPlay.IsOnRed === false && Objects[jh67].ObjectN !== 2) {



				continue;



			}



				var ab = ((Objects[jh67].X - PlayerInPlay.X));

				var bb = (Objects[jh67].Y - PlayerInPlay.Y);



				if (ab < 0) {



					//ab = 110 - ab;



				}

				else {



					//ab = 110 - ab;

				}



				if (bb < 0) {



					//bb = 80 - bb;



				}

				else {



					//bb = 80 - bb;

				}





				ActualInputs.push(ab / 220);

				ActualInputs.push(bb / 180);



			

			





		}



		for (jh67 = 0; jh67 < Objects.length; jh67++) {



			if (PlayerInPlay.crashWith(Objects[jh67], PlayerInPlay.X, PlayerInPlay.Y)) {



				ActualInputs.push(1);



			}

			else {



				ActualInputs.push(0);



			}



		}

		if (PlayerInPlay.IsOnRed && PlayerInPlay.X > 5) {



			ActualInputs.push(1);



		}

		else if (PlayerInPlay.IsOnRed === false && PlayerInPlay.X < -5) {



			ActualInputs.push(1);



		}

		else {



			ActualInputs.push(0);



		}



		if (PlayerInPlay.IsOnRed && agentFrameB > 0) {



			ActualInputs.push(1);



		}

		else if (PlayerInPlay.IsOnRed === false && agentFrameR > 0) {



			ActualInputs.push(1);



		}

		else {



			ActualInputs.push(0);



		}

		/*

		if (PlayerInPlay.IsOnRed) {





			var PlayKeep = -1;





			for (l45 = 0; l45 < AgentsB.length; l45++) {



				if (l45 != k) {



					var Distance = Math.sqrt((AgentsB[l45].X - PlayerInPlay.X) + (AgentsB[l45].Y - PlayerInPlay.Y));



					if (Distance < (KillDistance * 100) && AgentsB[l45].Al) {



						PlayKeep++;

						if (PlayKeep < NumberOthers) {



							ActualInputs[PlayKeep] = Distance / 200;



						}





					}





				}





			}







		}



		else {



			var PlayKeep = -1;



			for (l45 = 0; l45 < AgentsR.length; l45++) {



				if (l45 != k) {



					var Distance = Math.sqrt((AgentsR[l45].X - PlayerInPlay.X) + (AgentsR[l45].Y - PlayerInPlay.Y));



					if (Distance < ((KillDistance + .05) * 100) && AgentsR[l45].Al) {



						PlayKeep++;

						if (PlayKeep < NumberOthers) {



							ActualInputs[PlayKeep] = Distance / 200;



						}



					}





				}





			}



		}

		/*

		for (l = 0; l < Objects.length; l++) {



			ActualInputs.push((Objects[l].X - PlayerInPlay.X) / 200);

			ActualInputs.push((Objects[l].Y - PlayerInPlay.Y) / 200);



		}

		*/



		/*

		for (l = 0; l < PlayerInPlay.ObjectsCollected.length; l++) {



			ActualInputs.push(PlayerInPlay.ObjectsCollected[l]);



		}

		*/



		var Out = ForwardPass(PlayerInPlay.W, PlayerInPlay.B, CrewSetup, ActualInputs);



		var NewMoveX = Out[0] * 5;

		var NewMoveY = Out[1] * 5;

		var kill = (Out[2] > 0);

		

		if (PlayerInPlay.IsOnRed) {



			if (kill && PlayerInPlay.Al && Sub > agentFrameR[k]) {



				for (l45 = 0; l45 < Others.length; l45++) {



					if (l45 != k) {



						var Distance = Math.sqrt(Math.pow((Others[l45].X - PlayerInPlay.X), 2) + Math.pow((Others[l45].Y - PlayerInPlay.Y), 2));



						if (Distance < (KillDistance * 100) && Others[l45].Al && PlayerInPlay.X < -5) {



							var goodtokill = true;



							for (nhg67 = 0; nhg67 < Agents[k].alreadykilled.length; nhg67++) {



								if (Agents[k].alreadykilled[nhg67] === l45) {



									goodtokill = false;



								}



							}



							



							if (goodtokill) {

								if (Others[l45].ID === 1) {

									AgentsB1[Others[l45].Te].Al = false;

								}

								if (Others[l45].ID === 2) {

									AgentsB2[Others[l45].Te].Al = false;

								}



								if (Others[l45].ID === 3) {

									AgentsB3[Others[l45].Te].Al = false;

								}



								if (Others[l45].ID === 4) {

									AgentsB4[Others[l45].Te].Al = false;

								}



								if (Others[l45].ID === 5) {

									AgentsB5[Others[l45].Te].Al = false;

								}



								

								//AgentsB[Others[l45].AgentN].Score -= 30;

								Agents[k].score += 500;

								Agents[k].alreadykilled.push(l45);



								



									Dead++;

								

								

								

							}

							



						}

						



					}





				}



			}



		}

		if (PlayerInPlay.IsOnRed === false) {



			if (kill && PlayerInPlay.Al && Sub > agentFrameB[k]) {



				for (l45 = 0; l45 < Others.length; l45++) {



					if (l45 != k) {



						var Distance = Math.sqrt(Math.pow((Others[l45].X - PlayerInPlay.X), 2) + Math.pow((Others[l45].Y - PlayerInPlay.Y), 2));



						if (Distance < (KillDistance * 100) && Others[l45].Al && PlayerInPlay.X > 5) {



							var goodtokill = true;



							for (nhg67 = 0; nhg67 < Agents[k].alreadykilled.length; nhg67++) {



								if (Agents[k].alreadykilled[nhg67] === l45) {



									goodtokill = false;



								}



							}







							if (goodtokill) {

								if (Others[l45].ID === 1) {

									AgentsR1[Others[l45].Te].Al = false;

								}

								if (Others[l45].ID === 2) {

									AgentsR2[Others[l45].Te].Al = false;

								}



								if (Others[l45].ID === 3) {

									AgentsR3[Others[l45].Te].Al = false;

								}



								if (Others[l45].ID === 4) {

									AgentsR4[Others[l45].Te].Al = false;

								}



								if (Others[l45].ID === 5) {

									AgentsR5[Others[l45].Te].Al = false;

								}

								

								//AgentsR[Others[l45].AgentN].Score -= 500;

								Agents[k].score += 500;

								Agents[k].alreadykilled.push(l45);







								Dead++;







							}





						}





					}





				}



			}



		}



		if (PlayerInPlay.X + NewMoveX > 110 || PlayerInPlay.X + NewMoveX + PlayerInPlay.Wi < -110) {



			NewMoveX = 0;

			





		}



		if (PlayerInPlay.Y + NewMoveY + PlayerInPlay.He > 80 || PlayerInPlay.Y + NewMoveY < -80) {



			NewMoveY = 0;





		}





		for (l67 = 0; l67 < Objects.length; l67++) {





			if (PlayerInPlay.IsOnRed === false && PlayerInPlay.Al) {



				if (PlayerInPlay.crashWith(Objects[l67], PlayerInPlay.X + NewMoveX, PlayerInPlay.Y + NewMoveY) && kill && Objects[l67].ObjectN === 2) {



					if (Agents[k].ObjectsCollected.length === 0) {



						Agents[k].ObjectsCollected.push(1);

						agentFrameR[k] = Sub + 1000;

						Agents[k].score += 500;

						/*

						if (Agents[k].ID !== 1) {



							AgentsB1[k].score += 500;



						}

						if (Agents[k].ID !== 2) {



							AgentsB2[k].score += 500;



						}

						if (Agents[k].ID !== 3) {



							AgentsB3[k].score += 500;



						}

						if (Agents[k].ID !== 4) {



							AgentsB4[k].score += 500;



						}

						if (Agents[k].ID !== 5) {



							AgentsB5[k].score += 500;



						}

						*/

						AgentsR1[k].score -= 500;

						AgentsR2[k].score -= 500;

						AgentsR3[k].score -= 500;

						AgentsR4[k].score -= 500;

						AgentsR5[k].score -= 500;



					}



				}



			}

			

			if (PlayerInPlay.IsOnRed && PlayerInPlay.Al) {



				if (PlayerInPlay.crashWith(Objects[l67], PlayerInPlay.X + NewMoveX, PlayerInPlay.Y + NewMoveY) && kill && Objects[l67].ObjectN === 1) {



					if (Agents[k].ObjectsCollected.length === 0) {



						agentFrameB[k] = Sub + 1000;

						Agents[k].ObjectsCollected.push(1);

						Agents[k].score += 500;

						/*

						if (Agents[k].ID !== 1) {



							AgentsR1[k].score += 500;



						}

						if (Agents[k].ID !== 2) {



							AgentsR2[k].score += 500;



						}

						if (Agents[k].ID !== 3) {



							AgentsR3[k].score += 500;



						}

						if (Agents[k].ID !== 4) {



							AgentsR4[k].score += 500;



						}

						if (Agents[k].ID !== 5) {



							AgentsR5[k].score += 500;



						}

						*/

						AgentsB1[k].score -= 500;

						AgentsB2[k].score -= 500;

						AgentsB3[k].score -= 500;

						AgentsB4[k].score -= 500;

						AgentsB5[k].score -= 500;

						RedWins++;

					}



				}



			}

			





			if (PlayerInPlay.IsOnRed && PlayerInPlay.Y > -45 && PlayerInPlay.Y < 55 && PlayerInPlay.X > 5 && PlayerInPlay.X < 100) {



				Agents[k].score += .3;



			}

			if (PlayerInPlay.IsOnRed === false && PlayerInPlay.Y > -45 && PlayerInPlay.Y < 55 && PlayerInPlay.X < -5 && PlayerInPlay.X > -100) {



				Agents[k].score += .3;



			}



			





			

		}



		if (PlayerInPlay.IsOnRed && (PlayerInPlay.X + NewMoveX) > 5) {



			Agents[k].score += .25;



		}

		else if (PlayerInPlay.IsOnRed === false && (PlayerInPlay.X + NewMoveX) < -5) {



			Agents[k].score += .25;



		}



		if (PlayerInPlay.IsOnRed === false && (PlayerInPlay.X + NewMoveX) > 5) {



			for (nhl = 0; nhl < Others.length; nhl++) {

				var Distance = Math.sqrt(Math.pow((Others[nhl].X - PlayerInPlay.X), 2) + Math.pow((Others[nhl].Y - PlayerInPlay.Y), 2));



				if (Distance < (KillDistance * 200) && Others[nhl].X > 5 && Others[nhl].Al) {



					Agents[k].score += .25;



				}



			}



		}

		if (PlayerInPlay.IsOnRed && (PlayerInPlay.X + NewMoveX) < -5) {



			for (nhl = 0; nhl < Others.length; nhl++) {

				var Distance = Math.sqrt(Math.pow((Others[nhl].X - PlayerInPlay.X), 2) + Math.pow((Others[nhl].Y - PlayerInPlay.Y), 2));



				if (Distance < (KillDistance * 200) && Others[nhl].X < -5 && Others[nhl].Al) {



					Agents[k].score += .25;



				}



			}



		}

		



		if (PlayerInPlay.IsOnRed === false && (PlayerInPlay.X + NewMoveX) < -5) {



			for (nhl = 0; nhl < Others.length; nhl++) {

				var Distance = Math.sqrt(Math.pow((Others[nhl].X - PlayerInPlay.X), 2) + Math.pow((Others[nhl].Y - PlayerInPlay.Y), 2));



				if (Distance < (KillDistance * 50) && Others[nhl].X < -5 && Others[nhl].Al && PlayerInPlay.ObjectsCollected.length === 0) {



					Agents[k].score -= .1;



				}



			}



		}

		if (PlayerInPlay.IsOnRed && (PlayerInPlay.X + NewMoveX) > 5) {



			for (nhl = 0; nhl < Others.length; nhl++) {

				var Distance = Math.sqrt(Math.pow((Others[nhl].X - PlayerInPlay.X), 2) + Math.pow((Others[nhl].Y - PlayerInPlay.Y), 2));



				if (Distance < (KillDistance * 50) && Others[nhl].X > 5 && Others[nhl].Al && PlayerInPlay.ObjectsCollected.length === 0) {



					Agents[k].score -= .1;



				}



			}



		}





		for (l67 = 0; l67 < Wall.length; l67++) {



			if (PlayerInPlay.crashWith(Wall[l67], PlayerInPlay.X + NewMoveX, PlayerInPlay.Y)) {



				NewMoveX = 0;

				

				//Agents[k].score -= .5;



			}

			if (PlayerInPlay.crashWith(Wall[l67], PlayerInPlay.X, PlayerInPlay.Y + NewMoveY)) {



				NewMoveY = 0;



				//Agents[k].score -= .5;



			}

		}



		

		if (NewMoveX === 0 && NewMoveY === 0) {



			//Agents[k].score -= .5;



		}

		



		if (PlayerInPlay.Al) {



			Agents[k].X = PlayerInPlay.X + NewMoveX;

			Agents[k].Y = PlayerInPlay.Y + NewMoveY;



		}





		Agents[k].reDraw();





















	}



	return Agents;





}

var biggestVal = 0;





function MixUpList(List) {



	var listL = List.length;

	var newList = [];

	for (ghd65 = 0; ghd65 < listL; ghd65++) {



		var both = Math.floor(Math.random() * List.length)

		newList.push(List[both]);



		List.splice(both, 1);



	}



	return newList;



}



function Test() {



	

	Clear();

	

	Sub++;

	

	if (Sub > ChangesPerIteration) {



	



		PreviousValues.push(Dead);



		if (Dead > biggestVal) {



			biggestVal = Dead;



		}

		if (PreviousValues.length > 300) {

			PreviousValues.shift();

		}



		

		










		agentFrameR = [];



		for (b56 = 0; b56 < agentsCount; b56++) {





			agentFrameR.push(0);



		}

		agentFrameB = [];



		for (b56 = 0; b56 < agentsCount; b56++) {





			agentFrameB.push(0);



		}







		Sub = 0; 

		Dead = 0;

		RedWins = 0;



		AgentsR1 = Evolution(AgentsR1);

		AgentsB1 = Evolution(AgentsB1);



		AgentsR2 = Evolution(AgentsR2);

		AgentsB2 = Evolution(AgentsB2);



		AgentsR3 = Evolution(AgentsR3);

		AgentsB3 = Evolution(AgentsB3);



		AgentsR4 = Evolution(AgentsR4);

		AgentsB4 = Evolution(AgentsB4);



		AgentsR5 = Evolution(AgentsR5);

		AgentsB5 = Evolution(AgentsB5);



		/*

		if (Shuffle) {



			AgentsR = MixUpList(AgentsR);

			AgentsB = MixUpList(AgentsB);



		}

		*/



		for (hfge23 = 0; hfge23 < AgentsR1.length; hfge23++) {



			AgentsR1[hfge23].alreadykilled = [];

			AgentsR2[hfge23].alreadykilled = [];

			AgentsR3[hfge23].alreadykilled = [];

			AgentsR4[hfge23].alreadykilled = [];

			AgentsR5[hfge23].alreadykilled = [];





		}

		for (hfge23 = 0; hfge23 < AgentsB1.length; hfge23++) {



			AgentsB1[hfge23].alreadykilled = [];

			AgentsB2[hfge23].alreadykilled = [];

			AgentsB3[hfge23].alreadykilled = [];

			AgentsB4[hfge23].alreadykilled = [];

			AgentsB5[hfge23].alreadykilled = [];





		}



		

		



		IterationKeepup++;

	}

	

	if(IterationKeepup > Iterations) {

		

		clearInterval(good);

		

		

		

	}



	for (lh = 0; lh < Objects.length; lh++) {



		Objects[lh].reDraw();



	}

	for (lh = 0; lh < Wall.length; lh++) {



		Wall[lh].reDraw();



	}



	if (Sub % 2 === 0) {



		AgentsR1 = TeamTest(AgentsR1);

		AgentsR2 = TeamTest(AgentsR2);

		AgentsR3 = TeamTest(AgentsR3);

		AgentsR4 = TeamTest(AgentsR4);

		AgentsR5 = TeamTest(AgentsR5);



		AgentsB1 = TeamTest(AgentsB1);

		AgentsB2 = TeamTest(AgentsB2);

		AgentsB3 = TeamTest(AgentsB3);

		AgentsB4 = TeamTest(AgentsB4);

		AgentsB5 = TeamTest(AgentsB5);

		



	}

	else {



		AgentsB1 = TeamTest(AgentsB1);

		AgentsB2 = TeamTest(AgentsB2);

		AgentsB3 = TeamTest(AgentsB3);

		AgentsB4 = TeamTest(AgentsB4);

		AgentsB5 = TeamTest(AgentsB5);



		AgentsR1 = TeamTest(AgentsR1);

		AgentsR2 = TeamTest(AgentsR2);

		AgentsR3 = TeamTest(AgentsR3);

		AgentsR4 = TeamTest(AgentsR4);

		AgentsR5 = TeamTest(AgentsR5);



	}

	

		











	

	

	

}



function Clear() {

	

	ctx.clearRect(-1000, -1000, 2000, 2000);

	

}



function ForwardPass(Weights, Bias, Reference, Inputs) {

	var C = Inputs;



	var keepup = -1;

	var keepupB = -1;

	

	for (i678 = 0; i678 < Reference.length - 1; i678++) {

		

		var PreC = [];

		for (i679 = 0; i679 < Reference[i678 + 1]; i679++) {

			keepupB++;

			var sum = 0;

			for (u = 0; u < C.length; u++) {

				

				keepup++;

				sum += Weights[keepup].Va * C[u];

				

				

				

			}

	

			PreC.push(Math.tanh(sum + Bias[keepupB].Va));

			

			

			

		}

		

		C = [];

		

		for (uy = 0; uy < PreC.length; uy++) {

			

			C.push(PreC[uy]);

			

		}

		

		

	}

	

	return C;

	

	

}



function Agent(Weights, Bias, AgentNum, x, y, Width, Height, Score, best, alive, Team, TE, PlayerIdentity) {

	

	this.W = Weights;

	this.B = Bias;

	this.AgentN = AgentNum;

	this.X = x;

	this.Y = y;

	this.Wi = Width;

	this.He = Height;

	this.score = Score;

	this.ObjectsCollected = [];

	this.BestPlayer = best;

	this.Al = alive;

	this.Te = Team;

	this.IsOnRed = TE;

	this.alreadykilled = [];

	this.StartX = x;

	this.StartY = y;

	this.ID = PlayerIdentity;



	this.reDraw = function() {

		

		







		if (this.Al === false && this.IsOnRed) {



			ctx.fillStyle = "#dba9a9";

			

			

		}

		else if (this.Al === false && this.IsOnRed === false) {



			ctx.fillStyle = "#8e8cba";





		}

		else if (this.BestPlayer) {



			ctx.fillStyle = "#d6801e";



		}

		else {



			if (this.IsOnRed) {



				ctx.fillStyle = "#ff0000";



			}

			else {



				ctx.fillStyle = "#0000ff";



			}

			



		}

		

		ctx.fillRect(this.X, this.Y, this.Wi, this.He);

	

	}

	

	 this.crashWith = function(otherobj, X, Y) {

			var myleft = X;

			var myright = X + (this.Wi);

			var mytop = Y;

			var mybottom = Y + (this.He);

			var otherleft = otherobj.X;

			var otherright = otherobj.X + (otherobj.Wi);

			var othertop = otherobj.Y;

			var otherbottom = otherobj.Y + (otherobj.He);

			var crash = true;

			if ((mybottom < othertop) ||

			(mytop > otherbottom) ||

			(myright < otherleft) ||

			(myleft > otherright)) {

			  crash = false;

			}

			return crash;

	}

	

}



function Object(ObjectNum, x, y, Width, Height) {

	

	this.ObjectN = ObjectNum;

	this.X = x;

	this.Y = y;

	this.Wi = Width;

	this.He = Height;

	

	this.reDraw = function() {

		

		ctx.fillStyle = "#b33236";

		ctx.fillRect(this.X, this.Y, this.Wi, this.He);

	

	}

	

	

} 



function Walls(x, y, Width, Height) {



	this.X = x;

	this.Y = y;

	this.Wi = Width;

	this.He = Height;



	this.reDraw = function () {



		ctx.fillStyle = "#000000";

		ctx.fillRect(this.X, this.Y, this.Wi, this.He);



	}





} 



function Weights(reference) {

	

	var RandomVar = [];

		

	  for (u = 0; u < reference.length - 1; u++) {

			

			for (u2 = 0; u2 < reference[u] * reference[u + 1]; u2++) {

				

				var Lay = u;

				var Va = ((Math.random() * 2) - 1) * 0.5;

				

				RandomVar.push({Lay, Va});

				

			}

		

		}

		

	return RandomVar;

	

} 



function Bias(reference) {

	

	var RandomVar = [];

		

		

		for (u = 1; u < reference.length; u++) {

			

			for (u2 = 0; u2 < reference[u]; u2++) {

				

				var Lay = u - 1;

				var Va = ((Math.random() * 2) - 1) * 0.1;

				

				RandomVar.push({Lay, Va});

				

			}

		

			

		}

	

		return RandomVar;

} 












		  
		  </script>

    <style data-tag="default-style-sheet">
      html {
        font-family: Inter;
        font-size: 16px;
      }

      body {
        font-weight: 400;
        font-style:normal;
        text-decoration: none;
        text-transform: none;
        letter-spacing: normal;
        line-height: 1.15;
        color: var(--dl-color-theme-neutral-dark);
        background: var(--dl-color-theme-neutral-light);

        fill: var(--dl-color-theme-neutral-dark);
      }
    </style>
    <link
      rel="stylesheet"
      href="https://unpkg.com/animate.css@4.1.1/animate.css"
    />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Inter:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&amp;display=swap"
      data-tag="font"
    />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=STIX+Two+Text:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&amp;display=swap"
      data-tag="font"
    />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Noto+Sans:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&amp;display=swap"
      data-tag="font"
    />
    <link
      rel="stylesheet"
      href="https://unpkg.com/@teleporthq/teleport-custom-scripts/dist/style.css"
    />
  </head>
  <body>
    <link rel="stylesheet" href="./style.css" />
    <div>
      <link
        href="./computer-plays-capture-the-flag.css"
        rel="stylesheet"
      />

      <div class="creating-my-face-with-machine-learning-container1">
        <blog-post-header31-wrapper class="blog-post-header31-wrapper">
          <!--BlogPostHeader31 component-->
          <div class="blog-post-header31-content1 thq-section-padding">
            <div class="blog-post-header31-max-width thq-section-max-width">
              <div class="blog-post-header31-header">
                <div class="blog-post-header31-content2">
                  <div class="blog-post-header31-breadcrumbs1">
                    <svg
                      viewBox="0 0 1024 1024"
                      class="blog-post-header31-icon1"
                    >
                      <path
                        d="M658 708l-60 60-256-256 256-256 60 60-196 196z"
                      ></path>
                    </svg>
                    <a
                      href="index.html"
                      class="blog-post-header31-text1 thq-body-small"
                    >
                      <span>Home</span>
                      <br />
                    </a>
                  </div>
                  <div class="blog-post-header31-breadcrumbs2"></div>
                  <h1 class="blog-post-header31-text4 thq-heading-1">
                    <fragment
                      class="creating-my-face-with-machine-learning-fragment1"
                    >
                      <span
                        class="creating-my-face-with-machine-learning-text1"
                      >
                        Computer Plays Capture the Flag
                      </span>
                    </fragment>
                  </h1>
                </div>
              </div>
              <div class="blog-post-header31-content3">
                <div class="blog-post-header31-avatar">
                  <div class="blog-post-header31-content4">
                    <span class="blog-post-header31-text5 thq-body-small">
                      <fragment
                        class="creating-my-face-with-machine-learning-fragment2"
                      >
                        <span
                          class="creating-my-face-with-machine-learning-text2"
                        >
                        November 18, 2020 → December 12, 2020
                        </span>
                      </fragment>
                    </span>
                    <div class="blog-post-header31-time"></div>
                  </div>
                </div>
                <div class="blog-post-header31-share-buttons"></div>
              </div>
            </div>
          </div>
        </blog-post-header31-wrapper>
        <div
          class="creating-my-face-with-machine-learning-container2 thq-section-padding"
        >
          <div
            class="creating-my-face-with-machine-learning-max-width thq-section-max-width"
          >
            <div
              class="creating-my-face-with-machine-learning-content thq-flex-column"
            >
              <ul
                class="creating-my-face-with-machine-learning-ul thq-flex-column"
              >
                <li class="list-item thq-flex-column">
                  <h2
                    class="creating-my-face-with-machine-learning-heading1 thq-heading-2"
                  >
                    Basic Explaination
                  </h2>
                  <p class="thq-body-small">
                    <span>
                      Basic computer evolution is an almost direct simulation of the evolution that exists among real biological species. 
                      I wanted to apply this process for learning the optimal way to win a game so I wrote some software for a computer 
                      to play capture the flag. The rules of this game are simple, each team is made up of 5 people. 
                      Their goal is to get to the other side and touch the opponents flag. If a player is on the opponent's turf, 
                      they can be tagged and taken out of the game, that is what the grayed-out blocks mean. The game ends when the time runs out 
                      (about 5 seconds) or the player reaches the opponent's flag.&nbsp;
                    </span>
                  </p>
                </li>
                <li class="list-item"></li>
                <li class="list-item">
                    <img
                      src="public\MainCourt.png"
                    /> 
                </li>
                <li>
                  <p class="thq-body-small">
                    <span>
                      What you will notice below is that there is a massive explosion of players once the game starts. 
                      This is because we are simulating every single game at the same time just to save time. Each player 
                      can still only see their 5 teamates and their 5 opponent's teamates.
                    </span>
                  </p>
                </li>
                <li>
                  <canvas style="border: solid #000000 4px;" id="CoolKid" width="500" height="200"></canvas>
                </li>
                <li>
                  <button style="padding: 10px; background-color: #7FCD58; font-size: 18px;" onclick="start()"><strong>Start!</strong></button>
                </li>
                <li>
                  <button style="padding: 10px; background-color: #E27171; font-size: 18px;" onclick="stop()"><strong>Stop!</strong></button>
                </li>
                <li>
                  <p class="thq-body-small">
                    <span>
                      This algorithm take hours if not days before the computer gets incredibly intelligent, but below is a video 
                      taken after 24 hours of continuous training. It looks like a lot at first but the computer has learned both 
                      defense techniques, such as the red team crowding the door waiting for blue to arrive, as well as techniques 
                      to get to the other side and dodge their opponents.
                    </span>
                  </p>
                </li>
                <li>
                  <video width="620" height="300" controls="">
                    <source src="public/CaptureTheFlagFinish.mp4" type="video/mp4">
                    
                  Your browser does not support the video tag.
                  </video>
                </li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </div>
  </body>
</html>
