<!doctype html>
<!--Quite a few clients strip your Doctype out, and some even apply their own. Many clients do honor your doctype and it can make things much easier if you can validate constantly against a Doctype.-->
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Computer Plays Capture the Flag with Basic Evolution</title>

<!-- Please use an inliner tool to convert all CSS to inline as inpage or external CSS is removed by email clients -->
<!-- important in CSS is used to prevent the styles of currently inline CSS from overriding the ones mentioned in media queries when corresponding screen sizes are encountered -->

<style type="text/css">
body {
	margin: 0;
}
body, table, td, p, a, li, blockquote {
	-webkit-text-size-adjust: none!important;
	font-family: sans-serif;
	font-style: normal;
	font-weight: 400;
}
button {
	width: 90%;
}

@media screen and (max-width:600px) {
/*styling for objects with screen size less than 600px; */
body, table, td, p, a, li, blockquote {
	-webkit-text-size-adjust: none!important;
	font-family: sans-serif;
}
table {
	/* All tables are 100% width */
	width: 100%;
}
.footer {
	/* Footer has 2 columns each of 48% width */
	height: auto !important;
	max-width: 48% !important;
	width: 48% !important;
}
table.responsiveImage {
	/* Container for images in catalog */
	height: auto !important;
	max-width: 30% !important;
	width: 30% !important;
}
table.responsiveContent {
	/* Content that accompanies the content in the catalog */
	height: auto !important;
	max-width: 66% !important;
	width: 66% !important;
}
.top {
	/* Each Columnar table in the header */
	height: auto !important;
	max-width: 48% !important;
	width: 48% !important;
}
.catalog {
	margin-left: 0%!important;
}
}

@media screen and (max-width:480px) {
/*styling for objects with screen size less than 480px; */
body, table, td, p, a, li, blockquote {
	-webkit-text-size-adjust: none!important;
	font-family: sans-serif;
}
table {
	/* All tables are 100% width */
	width: 100% !important;
	border-style: none !important;
}
.footer {
	/* Each footer column in this case should occupy 96% width  and 4% is allowed for email client padding*/
	height: auto !important;
	max-width: 96% !important;
	width: 96% !important;
}
.table.responsiveImage {
	/* Container for each image now specifying full width */
	height: auto !important;
	max-width: 96% !important;
	width: 96% !important;
}
.table.responsiveContent {
	/* Content in catalog  occupying full width of cell */
	height: auto !important;
	max-width: 96% !important;
	width: 96% !important;
}
.top {
	/* Header columns occupying full width */
	height: auto !important;
	max-width: 100% !important;
	width: 100% !important;
}
.catalog {
	margin-left: 0%!important;
}
button {
	width: 90%!important;
}
}
</style>
</head>
<body yahoo="yahoo">

<table width="100%"  cellspacing="0" cellpadding="0">
  <tbody>
    <tr>
      <td><table width="600"  align="center" cellpadding="0" cellspacing="0">
          <!-- Main Wrapper Table with initial width set to 60opx -->
          <tbody>
            <tr>
              <td><table bgcolor="#d0cfcf" class="top" width="48%"  align="left" cellpadding="0" cellspacing="0" style="padding:10px 10px 10px 10px;">
                  <!-- First header column with Logo -->
                  <tbody>
                    <tr>
						
                      <td style="text-align: center;"><a href="index.html" style="text-decoration:none; font-size: 12px; color:#929292; text-align: center; font-family: sans-serif;">Home!</a></td>
                    </tr>
                  </tbody>
                </table>
                <table bgcolor="#d0cfcf" class="top" width="48%"  align="left" cellpadding="0" cellspacing="0" style="padding:10px 10px 10px 10px; text-align:left">
                  <!-- Second header column with ISSUE|DATE -->
                  <tbody>
                    <tr>
                      <td style="text-align: center;"><a href="about.html" style="text-decoration:none; font-size: 12px; color:#929292; text-align: left; font-family: sans-serif;">About</a></td>
                    </tr>
                  </tbody>
                </table></td>
            </tr>
            <tr> 
              <!-- HTML Spacer row -->
              <td style="font-size: 0; line-height: 0;" height="20"><table width="96%" align="left"  cellpadding="0" cellspacing="0">
                  <tr>
                    <td style="font-size: 0; line-height: 0;" height="20">&nbsp;</td>
                  </tr>
                </table></td>
            </tr>
            <tr> 
              <!-- HTML IMAGE SPACER -->
              <td style="font-size: 0; line-height: 0;" height="20"><table align="left"  cellpadding="0" cellspacing="0" >
                  <tr>
                    <td >&nbsp;</td>
                  </tr>
                </table></td>
            </tr>
            <tr> 
              <!-- Introduction area -->
              <td><table width="96%"  align="left" cellpadding="0" cellspacing="0">
                  <tr> 
                    <!-- row container for TITLE/EMAIL THEME -->
                    <td align="Left" style="font-size: 25px; font-weight: 300; line-height: 2.5em; color: #929292; font-family: sans-serif;"><strong>Computer Plays Capture the Flag with Evolution</strong></td>
                  </tr>
                  <tr> 
                    <!-- row container for Tagline -->
                    <td align="Left" style="font-size: 16px; font-weight:1000; color: #929292; font-family: sans-serif;">&nbsp;Date: November 18, 2020 â†’ December 12, 2020 </td>
                  </tr>
				  <tr> 
                    <!-- row container for Tagline -->
                    <td align="Left" style="font-size: 16px; font-weight:1000; color: #929292; font-family: sans-serif;">&nbsp;Type: Personal Project, Machine Learning and Computer Science </td>
                  </tr>
                  <tr>
                    <td style="font-size: 0; line-height: 0;" height="20"><table width="96%" align="left"  cellpadding="0" cellspacing="0">
                        <tr> 
                          <!-- HTML Spacer row -->
                          <td style="font-size: 0; line-height: 0;" height="20">&nbsp;</td>
                        </tr>
                      </table></td>
                  </tr>
                  <tr> 
                    <!-- Row container for Intro/ Description -->
                    <td align="left" style="font-size: 14px; font-style: normal; font-weight: 100; color: #929292; line-height: 1.8; text-align:justify; padding:10px 20px 0px 20px; font-family: sans-serif;"></td>
                  </tr>
                </table></td>
            </tr>
	
			   <tr> 
                    <!-- row container for Tagline -->
                    <td align="Left" style="padding:20px 0px 0px 5px; font-size: 16px; font-weight:1000; color: #929292; font-family: sans-serif;"><strong>Basic Explanation&nbsp;&nbsp;</strong></td>
            </tr>
            <tr> 
              <!-- HTML Spacer row -->
              <td style="font-size: 16; line-height: 1.6;" height="10"><table width="96%" align="left"  cellpadding="0" cellspacing="0">
                  <tr>
                   		<td align="Left" style="padding:20px 0px 0px 5px; font-size: 16px; font-weight:1000; color: #929292; font-family: sans-serif;"><p>Basic computer evolution is an almost direct simulation of the evolution that exists among real biological species. I wanted to apply this process for learning the optimal way to win a game so I wrote some software for a computer to play capture the flag. </p> 
					  	
					  <p>The rules of this game are simple, each team is made up of 5 people. Their goal is to get to the other side and touch the opponents flag. If a player is on the opponent's turf, they can be tagged and taken out of the game, that is what the grayed-out blocks mean. The game ends when the time runs out (about 5 seconds) or the player reaches the opponent's flag.</p></td>
                  </tr>
				  <tr>
			  
			  		<td><img width="500" height="300" src="images/MainCourt.png"></td>
			  
			  </tr>
				  <tr>
							
						<td align="Left" style="padding:20px 0px 0px 5px; font-size: 16px; font-weight:1000; color: #929292; font-family: sans-serif;"><p> What you will notice below is that there is a massive explosion of players once the game starts. This is because we are simulating every single game at the same time just to save time. Each player can still only see their 5 teamates and their 5 opponent's teamates. 
					</p></td>
                  </tr>
				  
			
				  
                </table></td>
            </tr>
			  
			  <tr>
			  
			  
			  	<td align="Left" style="padding:20px 0px 0px 5px; font-size: 20px; font-weight:1000; color: #929292; font-family: sans-serif;"><strong>Web Version</strong></td>
			  
			  </tr>
			  
			  <tr>
			  
				  <td><canvas style="border: solid #000000 4px;" id="CoolKid" width="500" height="200"></canvas></td>
			  </tr>
			  <tr>
			  
				  <td><button style="padding: 10px; background-color: #7FCD58; font-size: 18px;" onClick="start()"><strong>Start!</strong></button></td>
			  
			  
			  </tr>
			  <tr style="line-height:3;">
			  
				  <td><button style="padding: 10px; background-color: #E27171; font-size: 18px;" onClick="stop()"><strong>Stop!</strong></button></td>
			  
			  
			  </tr>
			  
			  <tr>
			  
				  <td align="Left" style="padding:20px 0px 0px 5px; font-size: 16px; font-weight:1000; color: #929292; font-family: sans-serif; line-height: 1.6;"><p>This algorithm take hours if not days before the computer gets incredibly intelligent, but below is a video taken after 24 hours of continuous training. It looks like a lot at first but the computer has learned both defense techniques, such as the red team crowding the door waiting for blue to arrive,  as well as techniques to get to the other side and dodge their opponents. </p></td>
			  
			  </tr>
			  <tr>
			  
			  <td><video width="620" height="300" controls>
  					<source src="Videos/CaptureTheFlagFinish.mp4" type="video/mp4">
  					
					Your browser does not support the video tag.
					</video></td>
			  
			  </tr>
			  
			 
			  
			  
			 
<!-- SPLIT -->
	  
	  		
	  <!-- SPLIT -->
	  
	  	
  </tbody>
</table>
		  
<script type="text/javascript">

	var CrewSetup = [29, 10, 10, 3];



var AgentsR1 = [];

var AgentsB1 = [];



var AgentsR2 = [];

var AgentsB2 = [];



var AgentsR3 = [];

var AgentsB3 = [];



var AgentsR4 = [];

var AgentsB4 = [];



var AgentsR5 = [];

var AgentsB5 = [];



var Objects = [];

var Wall = [];



var agentsCount = 100;



var Iterations = 100000;



var MutationChance = 0.01;



var MutationChange = .05;



var RandomVariationOnes = 2;



var KillDistance = .1;



var ChangesPerIteration = 1000;



var TeamMates = 5;



var distanceBetweenMembers = 10;



var NumberOthers = 10;



var canvas;



var canvas2;



var Shuffle = false;



var ctx;

var ctx2;



var PreviousValues = [0];

var started = true;
	
	var started2 = true;
	
function stop() {
	
	
	clearInterval(good);
	
	started = true;
	
	AgentsB1 = [];
	AgentsR1 = [];
	
	AgentsB2 = [];
	AgentsR2 = [];
	
	AgentsB3 = [];
	AgentsR3 = [];
	
	AgentsB4 = [];
	AgentsR4 = [];
	
	AgentsB5 = [];
	AgentsR5 = [];
	
	
}

function start() {

	

	canvas = document.getElementById("CoolKid");

	//canvas2 = document.getElementById("RadChart");



	ctx = canvas.getContext("2d");

	//ctx2 = canvas2.getContext("2d");

	if (started) {
		
		if (started2) {
			
			ctx.translate(250, 100);
			
		}
		started2 = false;
		
		
		
	
	started = false;

	





	

	

	var ke = -1;

	for (o = 0; o < agentsCount; o++) {



		

			ke++;



			agentFrameB.push(0);	

			agentFrameR.push(0);



			



		AgentsR1.push(new Agent(Weights(CrewSetup), Bias(CrewSetup), ke, -70, 3, 10, 10, 100, false, true, o, true, 1));

		AgentsB1.push(new Agent(Weights(CrewSetup), Bias(CrewSetup), ke, 70, 3, 10, 10, 100, false, true, o, false, 1));



	

		AgentsR2.push(new Agent(Weights(CrewSetup), Bias(CrewSetup), ke, -70, 3, 10, 10, 100, false, true, o, true, 2));

		AgentsB2.push(new Agent(Weights(CrewSetup), Bias(CrewSetup), ke, 70, 3, 10, 10, 100, false, true, o, false, 2));



		

		AgentsR3.push(new Agent(Weights(CrewSetup), Bias(CrewSetup), ke, -70, 3, 10, 10, 100, false, true, o, true, 3));

		AgentsB3.push(new Agent(Weights(CrewSetup), Bias(CrewSetup), ke, 70, 3, 10, 10, 100, false, true, o, false, 3));



		

		AgentsR4.push(new Agent(Weights(CrewSetup), Bias(CrewSetup), ke, -70, 3, 10, 10, 100, false, true, o, true, 4));

		AgentsB4.push(new Agent(Weights(CrewSetup), Bias(CrewSetup), ke, 70, 3, 10, 10, 100, false, true, o, false, 4));



		

		AgentsR5.push(new Agent(Weights(CrewSetup), Bias(CrewSetup), ke, -70, 3, 10, 10, 100, false, true, o, true, 5));

		AgentsB5.push(new Agent(Weights(CrewSetup), Bias(CrewSetup), ke, 70, 3, 10, 10, 100, false, true, o, false, 5));



		



		

		

	}

	

	

		

	Objects.push(new Object(1, 50, 0, 15, 15));

	Objects.push(new Object(2, -50, 0, 15, 15));

	 



	Wall.push(new Walls(-5, -50, 10, 110));

	Wall.push(new Walls(-100, -50, 200, 5));

	Wall.push(new Walls(-100, 55, 200, 5));

	

	

	

	

	good = setInterval(Test, 1);

	

	}

	

	

}



function Evolution(AgentsList) {



	var NextGeneration = []

	var Final = [];

	for (u67 = 0; u67 < AgentsList.length; u67++) {

		

		var gen = AgentsList[u67].AgentN;

		var Score = AgentsList[u67].score;

		

		

		Final.push({gen, Score});

		

	}

	

	var cool = []

	Final.sort(function (a, b) { return a.Score - b.Score;});

	

	

	for (n = 0; n < AgentsList.length; n++) {

		

		cool.push(AgentsList[n]);

		

	}

	



	

	var Surviving = [];

	for (n = RandomVariationOnes; n < Final.length; n++) {

		

		const Chance = n / (Final.length - 1);

		

		if (Chance >= (Math.random() * 1)) {

			

			

			Surviving.push(Final[n].gen);

			

		}

		

		

	}

	

	//Weights, Bias, AgentNum, x, Width, Height, Score



	var AgentKeepup = -1;

	

	for (n = 0; n < Surviving.length; n++) {

		 

		AgentKeepup++;

		var ActualAgent = cool[(Surviving[n])];



		var Greatest = n === Surviving.length - 1



		NextGeneration.push(new Agent(ActualAgent.W, ActualAgent.B, AgentsList[AgentKeepup].AgentN, AgentsList[AgentKeepup].StartX, AgentsList[AgentKeepup].StartY, AgentsList[AgentKeepup].Wi, AgentsList[AgentKeepup].He, 100, Greatest, true, AgentsList[AgentKeepup].Te, AgentsList[AgentKeepup].IsOnRed, AgentsList[AgentKeepup].ID));

		 

	}



	for (n = RandomVariationOnes; n < (cool.length - Surviving.length); n++) {

		 

		

		

		var Index1 = Math.floor(Math.random() * Surviving.length);

		var Index2 = Math.floor(Math.random() * Surviving.length);



		var Chance21 = (Index1 + 1) / Surviving.length;

		var Chance22 = (Index2 + 1) / Surviving.length;



		var Check1 = Math.random();

		var Check2 = Math.random();



		if (Check1 > Chance21 || Check2 > Chance22) {



			n -= 1;



			continue;



		}



		if (Index1 === Index2) {



			n -= 1;



			continue

		}



		AgentKeepup++;



		var Parent1 = cool[Surviving[Index1]];

		var Parent2 = cool[Surviving[Index2]];

		

		var NewWeights = [];

		var NewBias = [];

		

		for (o = 0; o < Parent1.W.length; o++) {

			

			var ToporBottom = Math.floor(Math.random() * 2);

			var Mutated = Math.random() < MutationChance;

			

			if (ToporBottom === 0) {

				

				var Lay = Parent1.W[o].Lay;

				var Va = Parent1.W[o].Va;

				

				if (Mutated) {

					

					Va += (Math.random() * (MutationChange * 2)) - MutationChange;

				

				}

				

				NewWeights.push({Lay, Va});

				

			} 

			if (ToporBottom === 1) {

				

				var Lay = Parent2.W[o].Lay;

				var Va = Parent2.W[o].Va;

				

				if (Mutated) {

					

					Va += (Math.random() * (MutationChange * 2)) - MutationChange;

					

				}

				

				NewWeights.push({Lay, Va});

				

			} 

			

			

			

		} 

		for (o = 0; o < Parent1.B.length; o++) {

			

			var ToporBottom = Math.floor(Math.random() * 2);

			var Mutated = Math.random() < MutationChance;

			

			if (ToporBottom === 0) {

				

				var Lay = Parent1.B[o].Lay;

				var Va = Parent1.B[o].Va;

				

				if (Mutated) {

					

					Va += (Math.random() * (MutationChange * 2)) - MutationChange;

					

				}

				

				NewBias.push({Lay, Va});

				

			} 

			if (ToporBottom === 1) {

				

				var Lay = Parent2.B[o].Lay;

				var Va = Parent2.B[o].Va;

				

				if (Mutated) {

					

					Va += (Math.random() * (MutationChange * 2)) - MutationChange;

					

				}

				

				NewBias.push({Lay, Va});

				

			} 

			

			

			

		} 

		

		



		NextGeneration.push(new Agent(NewWeights, NewBias, AgentsList[AgentKeepup].AgentN, AgentsList[AgentKeepup].StartX, AgentsList[AgentKeepup].StartY, AgentsList[AgentKeepup].Wi, AgentsList[AgentKeepup].He, 100, false, true, AgentsList[AgentKeepup].Te, AgentsList[AgentKeepup].IsOnRed, AgentsList[AgentKeepup].ID));

		

	}

	for (n = 0; n < RandomVariationOnes; n++) {



		AgentKeepup++;



		NextGeneration.push(new Agent(Weights(CrewSetup), Bias(CrewSetup), AgentsList[AgentKeepup].AgentN, AgentsList[AgentKeepup].StartX, AgentsList[AgentKeepup].StartY, AgentsList[AgentKeepup].Wi, AgentsList[AgentKeepup].He, 100, false, true, AgentsList[AgentKeepup].Te, AgentsList[AgentKeepup].IsOnRed, AgentsList[AgentKeepup].ID));



	}





	return NextGeneration;

	

	

}



var good;

var Sub = 0;

var IterationKeepup = -1;



var Dead = 0;

var RedWins = 0;



var agentFrameR = [];

var agentFrameB = [];



function TeamTest(Agents) {





	



	for (k = 0; k < Agents.length; k++) {



		var PlayerInPlay = Agents[k];

		//Get Inputs

		var ActualInputs = [];

		var Others = []



		if (PlayerInPlay.IsOnRed) {



			Others.push(AgentsB1[k]);

			Others.push(AgentsB2[k]);

			Others.push(AgentsB3[k]);

			Others.push(AgentsB4[k]);

			Others.push(AgentsB5[k]);



		}

		else {





			Others.push(AgentsR1[k]);

			Others.push(AgentsR2[k]);

			Others.push(AgentsR3[k]);

			Others.push(AgentsR4[k]);

			Others.push(AgentsR5[k]);

			



		}



		if (PlayerInPlay.alreadykilled.length > 0) {



			//Agents[k].score += .5;



		}

		/*

		var Completed = false;

		for (l = 0; l < Objects.length; l++) {



			if (PlayerInPlay.ObjectsCollected[l] === 0) {





				Completed = true;

			}



		}





		if (Completed && PlayerInPlay.IsOnRed) {



		



			Agents[k].score = Agents[k].score - 1;

			

			





		}

		*/

		



/*

		for (jh67 = 0; jh67 < NumberOthers; jh67++) {

			ActualInputs.push(0);

		}

		*/



		for (jh67 = 0; jh67 < Others.length; jh67++) {



			

			var ab = ((Others[jh67].X - PlayerInPlay.X));

			var bb = (Others[jh67].Y - PlayerInPlay.Y);



			if (ab < 0) {



				//ab = 110 - ab;



			}

			else {



				//ab = 110 - ab;

			}



			if (bb < 0) {



				//bb = 80 - bb;



			}

			else {



				//bb = 80 - bb;

			}





				ActualInputs.push(ab / 220);

				ActualInputs.push(bb / 160);

			

		}



		for (l45 = 0; l45 < Others.length; l45++) {



			if (l45 != k) {



				var Distance = Math.sqrt(Math.pow((Others[l45].X - PlayerInPlay.X), 2) + Math.pow((Others[l45].Y - PlayerInPlay.Y), 2));



				if (Distance < (KillDistance * 100) && Others[l45].Al) {





					ActualInputs.push(1);



				}

				else {



					ActualInputs.push(0);



				}

			}

		}

		//1 === Red 2 === Blue



		for (jh67 = 0; jh67 < Objects.length; jh67++) {



			if (PlayerInPlay.IsOnRed && Objects[jh67].ObjectN !== 1) {



				break;



			}

			else if (PlayerInPlay.IsOnRed === false && Objects[jh67].ObjectN !== 2) {



				continue;



			}



				var ab = ((Objects[jh67].X - PlayerInPlay.X));

				var bb = (Objects[jh67].Y - PlayerInPlay.Y);



				if (ab < 0) {



					//ab = 110 - ab;



				}

				else {



					//ab = 110 - ab;

				}



				if (bb < 0) {



					//bb = 80 - bb;



				}

				else {



					//bb = 80 - bb;

				}





				ActualInputs.push(ab / 220);

				ActualInputs.push(bb / 180);



			

			





		}



		for (jh67 = 0; jh67 < Objects.length; jh67++) {



			if (PlayerInPlay.crashWith(Objects[jh67], PlayerInPlay.X, PlayerInPlay.Y)) {



				ActualInputs.push(1);



			}

			else {



				ActualInputs.push(0);



			}



		}

		if (PlayerInPlay.IsOnRed && PlayerInPlay.X > 5) {



			ActualInputs.push(1);



		}

		else if (PlayerInPlay.IsOnRed === false && PlayerInPlay.X < -5) {



			ActualInputs.push(1);



		}

		else {



			ActualInputs.push(0);



		}



		if (PlayerInPlay.IsOnRed && agentFrameB > 0) {



			ActualInputs.push(1);



		}

		else if (PlayerInPlay.IsOnRed === false && agentFrameR > 0) {



			ActualInputs.push(1);



		}

		else {



			ActualInputs.push(0);



		}

		/*

		if (PlayerInPlay.IsOnRed) {





			var PlayKeep = -1;





			for (l45 = 0; l45 < AgentsB.length; l45++) {



				if (l45 != k) {



					var Distance = Math.sqrt((AgentsB[l45].X - PlayerInPlay.X) + (AgentsB[l45].Y - PlayerInPlay.Y));



					if (Distance < (KillDistance * 100) && AgentsB[l45].Al) {



						PlayKeep++;

						if (PlayKeep < NumberOthers) {



							ActualInputs[PlayKeep] = Distance / 200;



						}





					}





				}





			}







		}



		else {



			var PlayKeep = -1;



			for (l45 = 0; l45 < AgentsR.length; l45++) {



				if (l45 != k) {



					var Distance = Math.sqrt((AgentsR[l45].X - PlayerInPlay.X) + (AgentsR[l45].Y - PlayerInPlay.Y));



					if (Distance < ((KillDistance + .05) * 100) && AgentsR[l45].Al) {



						PlayKeep++;

						if (PlayKeep < NumberOthers) {



							ActualInputs[PlayKeep] = Distance / 200;



						}



					}





				}





			}



		}

		/*

		for (l = 0; l < Objects.length; l++) {



			ActualInputs.push((Objects[l].X - PlayerInPlay.X) / 200);

			ActualInputs.push((Objects[l].Y - PlayerInPlay.Y) / 200);



		}

		*/



		/*

		for (l = 0; l < PlayerInPlay.ObjectsCollected.length; l++) {



			ActualInputs.push(PlayerInPlay.ObjectsCollected[l]);



		}

		*/



		var Out = ForwardPass(PlayerInPlay.W, PlayerInPlay.B, CrewSetup, ActualInputs);



		var NewMoveX = Out[0] * 5;

		var NewMoveY = Out[1] * 5;

		var kill = (Out[2] > 0);

		

		if (PlayerInPlay.IsOnRed) {



			if (kill && PlayerInPlay.Al && Sub > agentFrameR[k]) {



				for (l45 = 0; l45 < Others.length; l45++) {



					if (l45 != k) {



						var Distance = Math.sqrt(Math.pow((Others[l45].X - PlayerInPlay.X), 2) + Math.pow((Others[l45].Y - PlayerInPlay.Y), 2));



						if (Distance < (KillDistance * 100) && Others[l45].Al && PlayerInPlay.X < -5) {



							var goodtokill = true;



							for (nhg67 = 0; nhg67 < Agents[k].alreadykilled.length; nhg67++) {



								if (Agents[k].alreadykilled[nhg67] === l45) {



									goodtokill = false;



								}



							}



							



							if (goodtokill) {

								if (Others[l45].ID === 1) {

									AgentsB1[Others[l45].Te].Al = false;

								}

								if (Others[l45].ID === 2) {

									AgentsB2[Others[l45].Te].Al = false;

								}



								if (Others[l45].ID === 3) {

									AgentsB3[Others[l45].Te].Al = false;

								}



								if (Others[l45].ID === 4) {

									AgentsB4[Others[l45].Te].Al = false;

								}



								if (Others[l45].ID === 5) {

									AgentsB5[Others[l45].Te].Al = false;

								}



								

								//AgentsB[Others[l45].AgentN].Score -= 30;

								Agents[k].score += 500;

								Agents[k].alreadykilled.push(l45);



								



									Dead++;

								

								

								

							}

							



						}

						



					}





				}



			}



		}

		if (PlayerInPlay.IsOnRed === false) {



			if (kill && PlayerInPlay.Al && Sub > agentFrameB[k]) {



				for (l45 = 0; l45 < Others.length; l45++) {



					if (l45 != k) {



						var Distance = Math.sqrt(Math.pow((Others[l45].X - PlayerInPlay.X), 2) + Math.pow((Others[l45].Y - PlayerInPlay.Y), 2));



						if (Distance < (KillDistance * 100) && Others[l45].Al && PlayerInPlay.X > 5) {



							var goodtokill = true;



							for (nhg67 = 0; nhg67 < Agents[k].alreadykilled.length; nhg67++) {



								if (Agents[k].alreadykilled[nhg67] === l45) {



									goodtokill = false;



								}



							}







							if (goodtokill) {

								if (Others[l45].ID === 1) {

									AgentsR1[Others[l45].Te].Al = false;

								}

								if (Others[l45].ID === 2) {

									AgentsR2[Others[l45].Te].Al = false;

								}



								if (Others[l45].ID === 3) {

									AgentsR3[Others[l45].Te].Al = false;

								}



								if (Others[l45].ID === 4) {

									AgentsR4[Others[l45].Te].Al = false;

								}



								if (Others[l45].ID === 5) {

									AgentsR5[Others[l45].Te].Al = false;

								}

								

								//AgentsR[Others[l45].AgentN].Score -= 500;

								Agents[k].score += 500;

								Agents[k].alreadykilled.push(l45);







								Dead++;







							}





						}





					}





				}



			}



		}



		if (PlayerInPlay.X + NewMoveX > 110 || PlayerInPlay.X + NewMoveX + PlayerInPlay.Wi < -110) {



			NewMoveX = 0;

			





		}



		if (PlayerInPlay.Y + NewMoveY + PlayerInPlay.He > 80 || PlayerInPlay.Y + NewMoveY < -80) {



			NewMoveY = 0;





		}





		for (l67 = 0; l67 < Objects.length; l67++) {





			if (PlayerInPlay.IsOnRed === false && PlayerInPlay.Al) {



				if (PlayerInPlay.crashWith(Objects[l67], PlayerInPlay.X + NewMoveX, PlayerInPlay.Y + NewMoveY) && kill && Objects[l67].ObjectN === 2) {



					if (Agents[k].ObjectsCollected.length === 0) {



						Agents[k].ObjectsCollected.push(1);

						agentFrameR[k] = Sub + 1000;

						Agents[k].score += 500;

						/*

						if (Agents[k].ID !== 1) {



							AgentsB1[k].score += 500;



						}

						if (Agents[k].ID !== 2) {



							AgentsB2[k].score += 500;



						}

						if (Agents[k].ID !== 3) {



							AgentsB3[k].score += 500;



						}

						if (Agents[k].ID !== 4) {



							AgentsB4[k].score += 500;



						}

						if (Agents[k].ID !== 5) {



							AgentsB5[k].score += 500;



						}

						*/

						AgentsR1[k].score -= 500;

						AgentsR2[k].score -= 500;

						AgentsR3[k].score -= 500;

						AgentsR4[k].score -= 500;

						AgentsR5[k].score -= 500;



					}



				}



			}

			

			if (PlayerInPlay.IsOnRed && PlayerInPlay.Al) {



				if (PlayerInPlay.crashWith(Objects[l67], PlayerInPlay.X + NewMoveX, PlayerInPlay.Y + NewMoveY) && kill && Objects[l67].ObjectN === 1) {



					if (Agents[k].ObjectsCollected.length === 0) {



						agentFrameB[k] = Sub + 1000;

						Agents[k].ObjectsCollected.push(1);

						Agents[k].score += 500;

						/*

						if (Agents[k].ID !== 1) {



							AgentsR1[k].score += 500;



						}

						if (Agents[k].ID !== 2) {



							AgentsR2[k].score += 500;



						}

						if (Agents[k].ID !== 3) {



							AgentsR3[k].score += 500;



						}

						if (Agents[k].ID !== 4) {



							AgentsR4[k].score += 500;



						}

						if (Agents[k].ID !== 5) {



							AgentsR5[k].score += 500;



						}

						*/

						AgentsB1[k].score -= 500;

						AgentsB2[k].score -= 500;

						AgentsB3[k].score -= 500;

						AgentsB4[k].score -= 500;

						AgentsB5[k].score -= 500;

						RedWins++;

					}



				}



			}

			





			if (PlayerInPlay.IsOnRed && PlayerInPlay.Y > -45 && PlayerInPlay.Y < 55 && PlayerInPlay.X > 5 && PlayerInPlay.X < 100) {



				Agents[k].score += .3;



			}

			if (PlayerInPlay.IsOnRed === false && PlayerInPlay.Y > -45 && PlayerInPlay.Y < 55 && PlayerInPlay.X < -5 && PlayerInPlay.X > -100) {



				Agents[k].score += .3;



			}



			





			

		}



		if (PlayerInPlay.IsOnRed && (PlayerInPlay.X + NewMoveX) > 5) {



			Agents[k].score += .25;



		}

		else if (PlayerInPlay.IsOnRed === false && (PlayerInPlay.X + NewMoveX) < -5) {



			Agents[k].score += .25;



		}



		if (PlayerInPlay.IsOnRed === false && (PlayerInPlay.X + NewMoveX) > 5) {



			for (nhl = 0; nhl < Others.length; nhl++) {

				var Distance = Math.sqrt(Math.pow((Others[nhl].X - PlayerInPlay.X), 2) + Math.pow((Others[nhl].Y - PlayerInPlay.Y), 2));



				if (Distance < (KillDistance * 200) && Others[nhl].X > 5 && Others[nhl].Al) {



					Agents[k].score += .25;



				}



			}



		}

		if (PlayerInPlay.IsOnRed && (PlayerInPlay.X + NewMoveX) < -5) {



			for (nhl = 0; nhl < Others.length; nhl++) {

				var Distance = Math.sqrt(Math.pow((Others[nhl].X - PlayerInPlay.X), 2) + Math.pow((Others[nhl].Y - PlayerInPlay.Y), 2));



				if (Distance < (KillDistance * 200) && Others[nhl].X < -5 && Others[nhl].Al) {



					Agents[k].score += .25;



				}



			}



		}

		



		if (PlayerInPlay.IsOnRed === false && (PlayerInPlay.X + NewMoveX) < -5) {



			for (nhl = 0; nhl < Others.length; nhl++) {

				var Distance = Math.sqrt(Math.pow((Others[nhl].X - PlayerInPlay.X), 2) + Math.pow((Others[nhl].Y - PlayerInPlay.Y), 2));



				if (Distance < (KillDistance * 50) && Others[nhl].X < -5 && Others[nhl].Al && PlayerInPlay.ObjectsCollected.length === 0) {



					Agents[k].score -= .1;



				}



			}



		}

		if (PlayerInPlay.IsOnRed && (PlayerInPlay.X + NewMoveX) > 5) {



			for (nhl = 0; nhl < Others.length; nhl++) {

				var Distance = Math.sqrt(Math.pow((Others[nhl].X - PlayerInPlay.X), 2) + Math.pow((Others[nhl].Y - PlayerInPlay.Y), 2));



				if (Distance < (KillDistance * 50) && Others[nhl].X > 5 && Others[nhl].Al && PlayerInPlay.ObjectsCollected.length === 0) {



					Agents[k].score -= .1;



				}



			}



		}





		for (l67 = 0; l67 < Wall.length; l67++) {



			if (PlayerInPlay.crashWith(Wall[l67], PlayerInPlay.X + NewMoveX, PlayerInPlay.Y)) {



				NewMoveX = 0;

				

				//Agents[k].score -= .5;



			}

			if (PlayerInPlay.crashWith(Wall[l67], PlayerInPlay.X, PlayerInPlay.Y + NewMoveY)) {



				NewMoveY = 0;



				//Agents[k].score -= .5;



			}

		}



		

		if (NewMoveX === 0 && NewMoveY === 0) {



			//Agents[k].score -= .5;



		}

		



		if (PlayerInPlay.Al) {



			Agents[k].X = PlayerInPlay.X + NewMoveX;

			Agents[k].Y = PlayerInPlay.Y + NewMoveY;



		}





		Agents[k].reDraw();





















	}



	return Agents;





}

var biggestVal = 0;





function MixUpList(List) {



	var listL = List.length;

	var newList = [];

	for (ghd65 = 0; ghd65 < listL; ghd65++) {



		var both = Math.floor(Math.random() * List.length)

		newList.push(List[both]);



		List.splice(both, 1);



	}



	return newList;



}



function Test() {



	

	Clear();

	

	Sub++;

	

	if (Sub > ChangesPerIteration) {



	



		PreviousValues.push(Dead);



		if (Dead > biggestVal) {



			biggestVal = Dead;



		}

		if (PreviousValues.length > 300) {

			PreviousValues.shift();

		}



		

		










		agentFrameR = [];



		for (b56 = 0; b56 < agentsCount; b56++) {





			agentFrameR.push(0);



		}

		agentFrameB = [];



		for (b56 = 0; b56 < agentsCount; b56++) {





			agentFrameB.push(0);



		}







		Sub = 0; 

		Dead = 0;

		RedWins = 0;



		AgentsR1 = Evolution(AgentsR1);

		AgentsB1 = Evolution(AgentsB1);



		AgentsR2 = Evolution(AgentsR2);

		AgentsB2 = Evolution(AgentsB2);



		AgentsR3 = Evolution(AgentsR3);

		AgentsB3 = Evolution(AgentsB3);



		AgentsR4 = Evolution(AgentsR4);

		AgentsB4 = Evolution(AgentsB4);



		AgentsR5 = Evolution(AgentsR5);

		AgentsB5 = Evolution(AgentsB5);



		/*

		if (Shuffle) {



			AgentsR = MixUpList(AgentsR);

			AgentsB = MixUpList(AgentsB);



		}

		*/



		for (hfge23 = 0; hfge23 < AgentsR1.length; hfge23++) {



			AgentsR1[hfge23].alreadykilled = [];

			AgentsR2[hfge23].alreadykilled = [];

			AgentsR3[hfge23].alreadykilled = [];

			AgentsR4[hfge23].alreadykilled = [];

			AgentsR5[hfge23].alreadykilled = [];





		}

		for (hfge23 = 0; hfge23 < AgentsB1.length; hfge23++) {



			AgentsB1[hfge23].alreadykilled = [];

			AgentsB2[hfge23].alreadykilled = [];

			AgentsB3[hfge23].alreadykilled = [];

			AgentsB4[hfge23].alreadykilled = [];

			AgentsB5[hfge23].alreadykilled = [];





		}



		

		



		IterationKeepup++;

	}

	

	if(IterationKeepup > Iterations) {

		

		clearInterval(good);

		

		

		

	}



	for (lh = 0; lh < Objects.length; lh++) {



		Objects[lh].reDraw();



	}

	for (lh = 0; lh < Wall.length; lh++) {



		Wall[lh].reDraw();



	}



	if (Sub % 2 === 0) {



		AgentsR1 = TeamTest(AgentsR1);

		AgentsR2 = TeamTest(AgentsR2);

		AgentsR3 = TeamTest(AgentsR3);

		AgentsR4 = TeamTest(AgentsR4);

		AgentsR5 = TeamTest(AgentsR5);



		AgentsB1 = TeamTest(AgentsB1);

		AgentsB2 = TeamTest(AgentsB2);

		AgentsB3 = TeamTest(AgentsB3);

		AgentsB4 = TeamTest(AgentsB4);

		AgentsB5 = TeamTest(AgentsB5);

		



	}

	else {



		AgentsB1 = TeamTest(AgentsB1);

		AgentsB2 = TeamTest(AgentsB2);

		AgentsB3 = TeamTest(AgentsB3);

		AgentsB4 = TeamTest(AgentsB4);

		AgentsB5 = TeamTest(AgentsB5);



		AgentsR1 = TeamTest(AgentsR1);

		AgentsR2 = TeamTest(AgentsR2);

		AgentsR3 = TeamTest(AgentsR3);

		AgentsR4 = TeamTest(AgentsR4);

		AgentsR5 = TeamTest(AgentsR5);



	}

	

		











	

	

	

}



function Clear() {

	

	ctx.clearRect(-1000, -1000, 2000, 2000);

	

}



function ForwardPass(Weights, Bias, Reference, Inputs) {

	var C = Inputs;



	var keepup = -1;

	var keepupB = -1;

	

	for (i678 = 0; i678 < Reference.length - 1; i678++) {

		

		var PreC = [];

		for (i679 = 0; i679 < Reference[i678 + 1]; i679++) {

			keepupB++;

			var sum = 0;

			for (u = 0; u < C.length; u++) {

				

				keepup++;

				sum += Weights[keepup].Va * C[u];

				

				

				

			}

	

			PreC.push(Math.tanh(sum + Bias[keepupB].Va));

			

			

			

		}

		

		C = [];

		

		for (uy = 0; uy < PreC.length; uy++) {

			

			C.push(PreC[uy]);

			

		}

		

		

	}

	

	return C;

	

	

}



function Agent(Weights, Bias, AgentNum, x, y, Width, Height, Score, best, alive, Team, TE, PlayerIdentity) {

	

	this.W = Weights;

	this.B = Bias;

	this.AgentN = AgentNum;

	this.X = x;

	this.Y = y;

	this.Wi = Width;

	this.He = Height;

	this.score = Score;

	this.ObjectsCollected = [];

	this.BestPlayer = best;

	this.Al = alive;

	this.Te = Team;

	this.IsOnRed = TE;

	this.alreadykilled = [];

	this.StartX = x;

	this.StartY = y;

	this.ID = PlayerIdentity;



	this.reDraw = function() {

		

		







		if (this.Al === false && this.IsOnRed) {



			ctx.fillStyle = "#dba9a9";

			

			

		}

		else if (this.Al === false && this.IsOnRed === false) {



			ctx.fillStyle = "#8e8cba";





		}

		else if (this.BestPlayer) {



			ctx.fillStyle = "#d6801e";



		}

		else {



			if (this.IsOnRed) {



				ctx.fillStyle = "#ff0000";



			}

			else {



				ctx.fillStyle = "#0000ff";



			}

			



		}

		

		ctx.fillRect(this.X, this.Y, this.Wi, this.He);

	

	}

	

	 this.crashWith = function(otherobj, X, Y) {

			var myleft = X;

			var myright = X + (this.Wi);

			var mytop = Y;

			var mybottom = Y + (this.He);

			var otherleft = otherobj.X;

			var otherright = otherobj.X + (otherobj.Wi);

			var othertop = otherobj.Y;

			var otherbottom = otherobj.Y + (otherobj.He);

			var crash = true;

			if ((mybottom < othertop) ||

			(mytop > otherbottom) ||

			(myright < otherleft) ||

			(myleft > otherright)) {

			  crash = false;

			}

			return crash;

	}

	

}



function Object(ObjectNum, x, y, Width, Height) {

	

	this.ObjectN = ObjectNum;

	this.X = x;

	this.Y = y;

	this.Wi = Width;

	this.He = Height;

	

	this.reDraw = function() {

		

		ctx.fillStyle = "#b33236";

		ctx.fillRect(this.X, this.Y, this.Wi, this.He);

	

	}

	

	

} 



function Walls(x, y, Width, Height) {



	this.X = x;

	this.Y = y;

	this.Wi = Width;

	this.He = Height;



	this.reDraw = function () {



		ctx.fillStyle = "#000000";

		ctx.fillRect(this.X, this.Y, this.Wi, this.He);



	}





} 



function Weights(reference) {

	

	var RandomVar = [];

		

	  for (u = 0; u < reference.length - 1; u++) {

			

			for (u2 = 0; u2 < reference[u] * reference[u + 1]; u2++) {

				

				var Lay = u;

				var Va = ((Math.random() * 2) - 1) * 0.5;

				

				RandomVar.push({Lay, Va});

				

			}

		

		}

		

	return RandomVar;

	

} 



function Bias(reference) {

	

	var RandomVar = [];

		

		

		for (u = 1; u < reference.length; u++) {

			

			for (u2 = 0; u2 < reference[u]; u2++) {

				

				var Lay = u - 1;

				var Va = ((Math.random() * 2) - 1) * 0.1;

				

				RandomVar.push({Lay, Va});

				

			}

		

			

		}

	

		return RandomVar;

} 












		  
		  </script>		  



</body>
</html>

